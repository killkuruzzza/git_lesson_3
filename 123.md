# Инструкция для работы с Git и удаленными репозиториями # 

## Что такое Git?
Что такое Git?
Git - это одна из реализаций распределённых систем контроля версий, имеющая как и локальные, так и удалённые репозитории. Является самой популярной реализацией систем контроля версий в мире.

## Подготовка репозитория
Для создание репозитория необходимо выполнить команду git init в папке с репозиторием и у Вас создаться репозиторий (появится скрытая папка .git)

## Получение репозитория ## 
Создать локальную рабочую копию репозитория можно командой

    git clone /путь/к/репозиторию
Когда используется удаленный сервер, команда будет

    git clone юзер@хост:/путь/к/репозиторию

## Рабочий процесс ##
Ваш локальный git репозиторий состоит из трех "сущностей":   
**Рабочий каталог**
(Working Directory) содержит файлы.   
**Индекс**(Index) или область подготовленных файлов (Staging Area), содержит информацию о том, что должно войти в следующий коммит.  
**HEAD** указывает на последний коммит что вы сделали.
![Альтернативный текст](/trees.png)

## Подготовка и коммит ## 
Чтобы подготовить изменения (добавить их в Индекс), используйте   

    git add <имя_файла>

>`git add` Это первый шаг в основном рабочем процессе. Сделать коммит подготовленных изменений можно командой

    git commit -m "Описание коммита"

Теперь изменения закреплены в локальном репозитории, и на них указывает **HEAD**, но еще не в удаленном репозитории.

# Отправка изменений #
Чтобы отправить эти изменения в ваш удаленный репозиторий, выполните

    git push origin master
Можно изменить *master* на любую другую ветвь, чтобы отправить изменения на неё.

Если вы еще не клонировали существующий репозиторий и хотите подключить ваш к удаленному, вам нужно добавить его, выполнив

    git remote add origin <адрес_сервера>

Теперь вы можете отправлять изменения на удаленный репозиторий

## Ветвление 
Ветки используются для разработки функциональности, изолированной от остальной. Ветка *master* используется по умолчанию, когда вы создаете репозиторий. Используйте другие ветки для разработки и слияние в *master*, когда разработка завершена.
![Альтернативный текст](/branches.png)
Создать новую ветку с названием "feature_x" и переключиться на неё можно командой

    git checkout -b feature_x
переключиться обратно на *master*

    git checkout master

удалить ветку

    git branch -d feature_x
ветка не будет доступна тем, кто пользуется с вами удаленным репозиторием, пока вы не отправите её туда

    git push origin <имя_ветки>

## Обновление и слияние ## 
Обновить ваш локальный репозиторий можно командой

    git pull

которая заберет изменения из удаленного репозитория и проведет слияние с активной веткой.
Для того чтобы слить другую ветку с активной (например master), используйте команду

    git merge <имя_ветки>

В обоих случаях git пытается автоматически слить изменения. К сожалению, это не всегда возможно и результатом станет *конфликт*. Вы ответственны за разрешение возникших *конфликтов*, путем ручного редактирования файлов, указанных git. После изменений вам надо пометить их как слитые

    git add <имя_файла>

перед слиянием вы можете предварительно посмотреть на изменения

    git diff <имя_ветки> <имя_другой_ветки> 

## Метки #
Рекомендуется использовать метки для закрепления момента выпуска версий. Это популярная практика, которая также используется в SVN. Создать новую метку с именем 1.0.0 можно, выполнив

        git tag 1.0.0 1b2e1d63ff
1b2e1d63ff это первые десять цифр уникального идентификатора (id), с которым будет связана метка. Чтобы посмотреть идентификаторы коммитов, выполните

    git log
Можно использовать меньшее количество символов в качестве идентификатора, с учетом того, что он является уникальным.

## Замена локальных изменений
В случае, если вы сделали что-то не то, вы можете заменить локальные изменения, используя команду

    git checkout -- <имя_файла>
произойдет замена изменений в вашем рабочем каталоге, на то, что сейчас находится в HEAD. Изменения, уже внесенные в индекс, также как и новые файлы, будут сохранены.

Если же вы хотите удалить все ваши локальные изменения и коммиты, получите (fetch) последние изменения с сервера и укажите локальной ветке master на них вот так

    git fetch origin
    git reset --hard origin/master
## Твики и удобные команды
встроенный в git графический интерфейс

    gitk
использовать цветной вывод в терминале

    git config color.ui true
выводить в логе коммит на одной строке

    git config format.pretty oneline
интерактивный способ добавления в индекс

    git add -i
## Полезные функции
Git сложен: легко всё испортить, и нереально понять как исправить. Документация Git - это финиш: чтобы найти решение, тебе заранее надо знать название фишки, которая вернет всё на место.
### **Чёрт побери, я накосячил, где у git волшебная машина времени!?!**
    git reflog
    вы увидите список всего, что сделали в git, во всех ветках!
    у каждого элемента есть индекс HEAD@{индекс}
    найдите тот, перед которым всё сломалось
    git reset HEAD@{index}
    волшебная машина времени
Используйте это чтобы вернуть случайно удалённые штуки, или убрать то чем Вы всё сломали, или восстановиться после неудачного слияния, или просто вернуться туда, когда всё работало. Я ОЧЕНЬ ЧАСТО использую reflog. Снимаю шляпу перед теми, кто предложил добавить это.
### **Чёрт побери, я закоммитил и вспомнил, что кое-что забыл!**
    сделайте своё изменение
    git add . # или добавьте файлы по отдельности
    git commit --amend --no-edit
    теперь ваш последний коммит содержит это изменение!
    ПРЕДУПРЕЖДЕНИЕ: никогда не меняйте опубликованные коммиты!
Обычно я это использую когда коммичу, потом запускаю тесты/сканеры... и блин, я не поставил пробел после знака равно. Также можно сделать изменения в новом коммите и использовать rebase -i чтобы склеить оба коммита вместе, но так в миллион раз быстрее.

Предупреждение: никогда не изменяйте коммиты, отправленные в публичную ветку! Изменяйте только коммиты в вашей локальной ветке, иначе Вам не поздоровится.

### ***Чёрт побери, мне нужно изменить сообщение моего последнего коммита!***
    git commit --amend
    открывает редактор для смены сообщения
Дурацкие требования по наименованию.
### **Чёрт побери, Я случайно закоммитил что-то в мастер, хотя это должно быть в новой ветке!**
    создаст новую ветку из текущего состояния мастера
    git branch какое-то-имя-новой-ветки
    удалит последний коммит из мастера
    git reset HEAD~ --hard
    git checkout какое-то-имя-новой-ветки
    ваш коммит теперь живёт в этой ветке :)
NB: это не будет работать, если вы уже отправили коммит в удалённую ветку, и если вы пробовали сделать это как-то по-другому, может помочь git reset HEAD@{количество-коммитов-назад} вместо HEAD~. Грусть-печаль. Так же многие люди предлагали сделать то же самое, но короче. Спасибо всем!

### При запуске команды git init всё происходит только в локальном репозитории: в папке на компьютере пользователя, эту папку создавшего. Но для работы в команде программисты используют удаленные репозитории (сервис GitHub)

```
git clone <url> - копирование внешнего репозитория на свой ПК
git pull - скачать все из текущего(удаленного) репозитория и автоматическисделать merge с нашей версией
git push - отправить нашуверсию репозитория на внешний репозиторий. ТРЕБУЕТ АВТОРИЗАЦИИ на внешнем репозитории
```
## Как настроить совместную работу

1. Создать аккаунт на [GitHub.com](http://github.com/)
2. Создать локальный репозиторий
3. “Подружить” ваш локальный и удалённый репозитории.
GitHub при создании нового репозитория подскажет, как это можно сделать
4. Отправить (push) ваш локальный репозиторий в удалённый (на GitHub), при этом, возможно, вам нужно будет авторизоваться на удалённом репозитории
5. Провести изменения “с другого компьютера”
6. Выкачать (pull) актуальное состояние из удалённого репозитория

## Как сделать pull request

- Делаем (ответвление) fork репозитория
- Делаем git clone СВОЕЙ версии репозитория
- Создаем новую ветку и в НЕЕ вносим свои изменения
- Фиксируем изменения (делаем коммиты)
- Отправляем свою версию в свой GitHub
- На сайте GitHub нажимаем кнопку pull request