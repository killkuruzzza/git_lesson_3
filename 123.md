![Git](1.jpg)





   
   
Инструкция для работы с Git и удалёнными репозиториями
===================


## Что такое Git?
Git - это одна из реализаций распределенных систем контроля версий, имеющая как и локальные, так и удаленные репозитории. Является самой популярной реализацией систем контроля версий в мире.   

Скачать последнюю версию программы можно на официальном сайте: [https://git-scm.com](https://git-scm.com/downloads)
   


![arrow](2.png)   Перед началом работы нужно выполнить некоторые настройки:
===================

В открытом терминале (Открыть терминал можно через Меню: Вид -> Терминал или одновременным нажатием Ctrl и ~) ввести следующие команды:

*git config --global user.name "Your Name"* - указать имя, которым будут подписаны коммиты

*git config --global user.email "e@w.com"* - указать электропочту, которая будет в описании коммитера

Git хранит весь пакет конфигураций в файле *.gitconfig*, находящемся в вашем локальном каталоге. Чтобы сделать эти настройки глобальными, то есть применимыми ко всем проектам, необходимо добавить флаг *–global*. Если вы этого не сделаете, они будут распространяться только на текущий репозиторий.
Для того, чтобы посмотреть все настройки системы, используйте команду: 
*git config --list*


![arrow](2.png)   Подготовка к работе с локальными репозиториями:
===================    

## Подготовка репозитория
Чтобы создать новый репозиторий, нам нужно открыть терминал, зайти в папку нашего проекта и выполнить команду *init*. Это включит приложение в этой конкретной папке и создаст скрытую директорию *.git*, где будет храниться история репозитория и настройки.


## Определение состояния
*status* — это еще одна важнейшая команда, которая показывает информацию о текущем состоянии репозитория: актуальна ли информация на нём, нет ли чего-то нового, что поменялось, и так далее. Запуск *git status* на нашем свежесозданном репозитории должен выдать:

*$ git status   
On branch master   
Initial commit   
Untracked files:   
(use "git add ..." to include in what will be committed)   
hello.txt*   

Сообщение говорит о том, что файл *hello.txt* неотслеживаемый. Это значит, что файл новый и система еще не знает, нужно ли следить за изменениями в файле или его можно просто игнорировать. Для того, чтобы начать отслеживать новый файл, нужно его специальным образом объявить.   


## Подготовка файлов
В git есть концепция области подготовленных файлов, на которую необходимо добавить файлы (или части файлов, или даже одиночные строчки) командой *add* и закоммитить все нужное в репозиторий (создаем слепок нужного нам состояния) командой *commit*.

**Например**:

*$ git add hello.txt* 

Если нам нужно добавить все, что находится в директории, мы можем использовать *$ git add -A*


![arrow](2.png)   Фиксация изменений:
===================

## Как сделать коммит
Представим, что нам нужно добавить в файлы некоторые изменения. Для сохранения изменений, их необходимо закоммитить. Но сначала, мы должны обозначить эти файлы для Гита, при помощи команды *git add*, добавляющей (или подготавливающей) их к коммиту. Добавлять их можно по отдельности:

*git add file_01.* *   
*git add file_02.* *   
     
или вместе - всё сразу: *git add*.

Конечно добавлять всё сразу удобнее, чем прописывать каждую позицию отдельно, однако, тут надо быть внимательным, чтобы не добавить по ошибке ненужные элементы. Если же такое произошло изъять оттуда ошибочный файл можно при помощи команды:

*git reset:   
git reset file_01.* *   


**Теперь создадим непосредственно сам коммит:** 

*git commit -m 'Add some code'*   

Флажок *-m* задаст *commit message* - комментарий разработчика. Он необходим для описания закоммиченных изменений. И здесь работает золотое правило всех комментариев в коде: **«Максимально ясно, просто и содержательно обозначь написанное!»**   


## Как посмотреть коммиты
Для просмотра все выполненных фиксаций можно воспользоваться историей коммитов. Она содержит сведения о каждом проведенном коммите проекта. Запросить ее можно при помощи команды: *git log*   

В ней содержиться вся информация о каждом отдельном коммите, с указанием его хэша, автора, списка изменений и даты, когда они были сделаны. Отследить интересующие вас операции в списке изменений, можно по хэшу коммита, при помощи команды *git show* :  *git show hash_commit*   

Ну а если вдруг нам нужно переделать *commit message* и внести туда новый комментарий, можно написать следующую конструкцию:  *git commit --amend -m 'Новый комментарий'*   

В данном случае сообщение последнего коммита перезапишется. Но злоупотреблять этим не стоит, поскольку эта операция опасная и лучше ее делать до отправки коммита на сервер.

![arrow](2.png)  Ветвление
===================

Во время разработки новой функциональности считается хорошей практикой работать с копией оригинального проекта, которую называют веткой. Ветви имеют свою собственную историю и изолированные друг от друга изменения до тех пор, пока вы не решаете слить изменения вместе. Это происходит по набору причин:

1. Уже рабочая, стабильная версия кода сохраняется.
2. Различные новые функции могут разрабатываться параллельно разными программистами.
3. Разработчики могут работать с собственными ветками без риска, что кодовая база поменяется из-за чужих изменений.
4. В случае сомнений, различные реализации одной и той же идеи могут быть разработаны в разных ветках и затем сравниваться.

## Создание новой ветки

Основная ветка в каждом репозитории называется master. Чтобы создать еще одну ветку, используем команду *branch <name>*

*$ git branch new_branch*  

Это создаст новую ветку, пока что точную копию ветки *master*.

## Переключение между ветками

Сейчас, если мы запустим *branch*, мы увидим две доступные опции:

*$ git branch  
new_branch
*master*  

*master* — это активная ветка, она помечена звездочкой. Но мы хотим работать с нашей “новой веткой”, так что нам понадобится переключиться на другую ветку. Для этого воспользуемся командой *checkout*, она принимает один параметр — имя ветки, на которую необходимо переключиться.

*$ git checkout amazing_new_feature*

В Git ветка — это отдельная линия разработки. *Git checkout* позволяет нам переключаться как между удаленными, так и меду локальными ветками. Это один из способов получить доступ к работе коллеги или соавтора, обеспечивающий более высокую продуктивность совместной работы. Однако тут надо помнить, что пока вы не закомитили изменения, вы не сможете переключиться на другую ветку. В такой ситуации нужно либо сделать коммит, либо отложить его, при помощи команды *git stash*, добавляющей текущие незакоммиченные изменения в стек изменений и сбрасывающей рабочую копию до HEAD'а репозитория.

## Слияние веток   

Наша “новая ветка” будет еще одним текстовым файлом под названием *new.txt*. Мы создадим его, добавим и закоммитим:

*$ git add new.txt*

*$ git commit -m "Обновления.”*

Изменения завершены, теперь мы можем переключиться обратно на ветку *master*.

*$ git checkout master*

Теперь, если мы откроем наш проект в файловом менеджере, мы не увидим файла *new.txt*, потому что мы переключились обратно на ветку *master*, в которой такого файла не существует. Чтобы он появился, нужно воспользоваться *merge* для объединения веток (применения изменений из ветки *new_branch* к основной версии проекта).

*$ git merge new_branch*

Теперь ветка *master* актуальна. Ветка *new_branch* больше не нужна, и ее можно удалить.

*$ git branch -d new_branch*

Если хотите создать копию удаленного репозитория - используйте *git clone*. Однако если вам нужна только определенная его ветка, а не все хранилище - после *git clone* выполните следующую команду в соответствующем репозитории:

*git checkout -b <имя ветки> origin/<имя ветки>*

После этого, новая ветка создается на машине автоматически.

## Удаление веток

Бывают ситуации, когда после слива каких-то изменений из рабочей ветки в исходную версию проекта, ее, по правилам хорошего тона, необходимо удалить, чтобы она более не мешалась в вашем коде. Для локально расположенных веток существует команда:

*git branch -d local_branch_name*

где флажок *-d* являющийся опцией команды *git branch* - это сокращенная версия ключевого слова *--delete*, предназначенного для удаления ветки, а *local_branch_name* – название ненужной нам ветки.  
Однако тут есть нюанс: удалить текущую ветку, в которую вы, в данный момент просматриваете - нельзя. Если же вы все-таки попытаетесь это сделать, система отругает вас и выдаст ошибку с таким содержанием:

*Error: Cannot delete branch local_branch_name checked out at название_директории*  

Так что при удалении ветвей, обязательно переключитесь на другой *branch*.

![arrow](2.png)  Удаленные репозитории
===================

Сейчас наш коммит является локальным — существует только в директории *.git* на нашей файловой системе. Несмотря на то, что сам по себе локальный репозиторий полезен, в большинстве случаев мы хотим поделиться нашей работой или доставить код на сервер, где он будет выполняться.

## Что такое удаленный репозиторий

Репозиторий, хранящийся в облаке, на стороннем сервисе, специально созданном для работы с *git* имеет ряд преимуществ. Во-первых - это своего рода резервная копия вашего проекта, предоставляющая возможность безболезненной работы в команде. А еще в таком репозитории можно пользоваться дополнительными возможностями хостинга. К примеру -визуализацией истории или возможностью разрабатывать вашу программу непосредственно в веб-интерфейсе.

**Клонирование** - это когда вы копируете удаленный репозиторий к себе на локальный ПК. Это то, с чего обычно начинается любой проект. При этом вы переносите себе все файлы и папки проекта, а также всю его историю с момента его создания. Чтобы склонировать проект, сперва, необходимо узнать где он расположен и скопировать ссылку на него. Советую создать свой репозиторий в GitHub, BitBucket или любом другом сервисе:

*git clone https://github.com/ваш_адрес*

При клонировании в текущий каталог, там будет создана папка, в которую поместятся все проектные файлы и скрытая директория *.git*, с самим репозиторием, или с необходимой информацией о нем. В такой ситуации, для клонируемого репозитория, по умолчанию, будет создана папка с одноименным названием, но его можно залить и в другую директорию.

## Подключение к удаленному репозиторию

Чтобы загрузить что-нибудь в удаленный репозиторий, сначала нужно к нему подключиться. Регистрация и установка может занять время.
Чтобы связать наш локальный репозиторий с репозиторием на GitHub, выполним следующую команду в терминале. Обратите внимание, что нужно обязательно изменить URI репозитория на свой.

*$ git remote add origin https://github.com/ваш_адрес*  

Проект может иметь несколько удаленных репозиториев одновременно. Чтобы их различать, мы дадим им разные имена. Обычно главный репозиторий называется origin.

## Отправка изменений на сервер

Сейчас самое время переслать наш локальный коммит на сервер. Этот процесс происходит каждый раз, когда мы хотим обновить данные в удаленном репозитории.
Команда, предназначенная для этого - *push*. Она принимает два параметра: имя удаленного репозитория (мы назвали наш *origin*) и ветку, в которую необходимо внести изменения (*master* — это ветка по умолчанию для всех репозиториев).

*$ git push origin master   
Counting objects: 3, done.   
Writing objects: 100% (3/3), 212 bytes | 0 bytes/s, done.   
Total 3 (delta 0), reused 0 (delta 0)   
To https://github.com/ваш_адрес   
[new branch] master -> master*

Эта команда немного похожа на *git fetch*, с той лишь разницей, что при помощи *fetch* мы импортируем коммиты в локальную ветку, а применив *push*, мы экспортируем их из локальной в удаленную. Если вам необходимо настроить удаленную ветку используйте *git remote*. Однако пушить надо осторожно, ведь рассматриваемая команда перезаписывает безвозвратно все изменения. В большинстве случаев, ее используют, чтобы опубликовать выгружаемые локальные изменения в центральный репозиторий. А еще ее применяют для того, чтобы поделиться, внесенными в локальный репозиторий, нововведениями, с коллегами или другими удаленными участниками разработки проекта. Подытожив сказанное, можно назвать *git push* - командой выгрузки, *а git pull* и *git fetch* - командами загрузки или скачивания. После того как вы успешно запушили измененные данные, их необходимо внедрить или интегрировать, при помощи команды слияния *git merge*.

## Запрос изменений с сервера

Если вы сделали изменения в вашем удаленном репозитории, другие пользователи могут скачать изменения при помощи команды *pull*.

*$ git pull origin master   
From https://github.com/ваш_адрес   
branch master -> FETCH_HEAD   
Already up-to-date.*


Павлова Е.С.