igfisdhghdfgsklfdslgk
dfg;ldkfgsldfnsg;ns
f'sgn'slgsdf;\'n

# Шпаргалка по GIT         

![Logo](https://miro.medium.com/max/1400/1*L1wCPhdvK2guitLVNVCEtw.jpeg)

# Основные команды
===========================================================
+ ## _git add_
Команда ***git add*** добавляет содержимое рабочей директории в индекс (***staging area***) для последующего коммита. По умолчанию ***git commit*** использует лишь этот индекс, так что вы можете    использовать ***git add*** для сборки слепка вашего следующего коммита.
***
+ ## _git status_
Команда ***git status*** показывает состояния файлов в рабочей директории и индексе: какие файлы изменены, но не добавлены в индекс; какие ожидают коммита в индексе. Вдобавок к этому выводятся подсказки о том, как изменить состояние файлов.
***
+ ## _git diff_
Команда ***git diff*** используется для вычисления разницы между любыми двумя Git деревьями. Это может быть разница между вашей рабочей директорией и индексом (собственно ***git diff***), разница между индексом и последним коммитом (***git diff --staged***), или между любыми двумя коммитами (***git diff master branchB***).
***
+ ## _git difftool_
Команда ***git difftool*** просто запускает внешнюю утилиту сравнения для показа различий в двух деревьях, на случай если вы хотите использовать что-либо отличное от встроенного просмотрщика ***git diff***.
***
+ ## _git commit_
Команда ***git commit*** берёт все данные, добавленные в индекс с помощью ***git add***, и сохраняет их слепок во внутренней базе данных, а затем сдвигает указатель текущей ветки на этот слепок.
***
+ ## _git reset_
Команда ***git reset***, как можно догадаться из названия, используется в основном для отмены изменений. Она изменяет указатель ***HEAD*** и, опционально, состояние индекса. Также эта команда может изменить файлы в рабочей директории при использовании параметра ***--hard***, что может привести к потере наработок при неправильном использовании, так что убедитесь в серьёзности своих намерений прежде чем использовать его.
***
+ ## _git rm_
Команда ***git rm*** используется в Git для удаления файлов из индекса и рабочей директории. Она похожа на ***git add*** с тем лишь исключением, что она удаляет, а не добавляет файлы для следующего коммита.

+ ## _git mv_
Команда ***git mv*** — это всего лишь удобный способ переместить файл, а затем выполнить ***git add*** для нового файла и ***git rm*** для старого.
***
+ ## _git clean_
Команда ***git clean*** используется для удаления мусора из рабочей директории. Это могут быть результаты сборки проекта или файлы конфликтов слияний.
***
# Ветвление и слияние
===========================================================

+ ## _git branch_
Команда ***git branch*** — это своего рода “менеджер веток”. Она умеет перечислять ваши ветки, создавать новые, удалять и переименовывать их.
***
+ ## _git checkout_
Команда ***git checkout*** используется для переключения веток и выгрузки их содержимого в рабочую директорию.
***
+ ## _git merge_
Команда ***git merge*** используется для слияния одной или нескольких веток в текущую. Затем она устанавливает указатель текущей ветки на результирующий коммит.
***
+ ## _git mergetool_
Команда ***git mergetool*** просто вызывает внешнюю программу слияний, в случае если у вас возникли проблемы слияния.
***
+ ## _git log_
Команда ***git log*** используется для просмотра истории коммитов, начиная с самого свежего и уходя к истокам проекта. По умолчанию, она показывает лишь историю текущей ветки, но может быть настроена на вывод истории других, даже нескольких сразу, веток. Также её можно использовать для просмотра различий между ветками на уровне коммитов.
***
+ ## _git stash_
Команда ***git stash*** используется для временного сохранения всех незакоммиченных изменений для очистки рабочей директории без необходимости коммитить незавершённую работу в новую ветку.
***
+ ## _git tag_
Команда ***git tag*** используется для задания постоянной метки на какой-либо момент в истории проекта. Обычно она используется для релизов.

# Совместная работа и обновление проектов
===========================================================

Не так уж много команд в Git требуют сетевого подключения для своей работы, практически все команды оперируют с локальной копией проекта. Когда вы готовы поделиться своими наработками, всего несколько команд помогут вам работать с удалёнными репозиториями.

+ ## _git fetch_
Команда ***git fetch*** связывается с удалённым репозиторием и забирает из него все изменения, которых у вас пока нет и сохраняет их локально.
***
+ ## _git pull_
Команда ***git pull*** работает как комбинация команд ***git fetch*** и ***git merge*, т.е. Git вначале забирает изменения из указанного удалённого репозитория, а затем пытается слить их с текущей веткой.
***
+ ## _git push_
Команда ***git push*** используется для установления связи с удалённым репозиторием, вычисления локальных изменений отсутствующих в нём, и собственно их передачи в вышеупомянутый репозиторий. Этой команде нужно право на запись в репозиторий, поэтому она использует аутентификацию.
***
+ ## _git remote_
Команда ***git remote*** служит для управления списком удалённых репозиториев. Она позволяет сохранять длинные URL репозиториев в виде понятных коротких строк, например **"origin"**, так что вам не придётся забивать голову всякой ерундой и набирать её каждый раз для связи с сервером. Вы можете использовать несколько удалённых репозиториев для работы и ***git remote*** поможет добавлять, изменять и удалять их.
***
+ ## _git archive_
Команда ***git archive*** используется для упаковки в архив указанных коммитов или всего репозитория.
***
+ ## _git submodule_
Команда ***git submodule*** используется для управления вложенными репозиториями. Например, это могут быть библиотеки или другие, используемые не только в этом проекте ресурсы. У команды ***submodule*** есть несколько под-команд — ***add, update, sync*** и др. — для управления такими репозиториями.
***
# Осмотр и сравнение
===========================================================

+ ## _git show_
Команда ***git show*** отображает объект в простом и человекопонятном виде. Обычно она используется для просмотра информации о метке или коммите.
***
+ ## _git shortlog_
Команда ***git shortlog*** служит для подведения итогов команды ***git log***. Она принимает практически те же параметры, что и ***git log***, но вместо простого листинга всех коммитов, они будут сгруппированы по автору.
***
+ ## _git describe_
Команда ***git describe*** принимает на вход что угодно, что можно трактовать как коммит (ветку, тег) и выводит более-менее человекочитаемую строку, которая не изменится в будущем для данного коммита. Это может быть использовано как более удобная, но по-прежнему уникальная, замена **SHA-1**.

# Отладка
===========================================================

В Git есть несколько команд, используемых для нахождения проблем в коде. Это команды для поиска места в истории, где проблема впервые проявилась и собственно виновника этой проблемы.

+ ## _git bisect_
Команда ***git bisect*** — это чрезвычайно полезная утилита для поиска коммита в котором впервые проявился баг или проблема с помощью автоматического бинарного поиска.
***
+ ## _git blame_
Команда ***git blame*** выводит перед каждой строкой файла **SHA-1** коммита, последний раз менявшего эту строку и автора этого коммита. Это помогает в поисках человека, которому нужно задавать вопросы о проблемном куске кода.
***
+ ## _git grep_
Команда ***git grep*** используется для поиска любой строки или регулярного выражения в любом из файлов вашего проекта, даже в более ранних его версиях.

Если вы только начинаете работать с **Git**, или переходите на **Git** с другой СКВ, то такая шпаргалка может вам очень пригодиться.

## Другие материалы по теме:
[Сайт GIT](https://git-scm.com/)

[Сайт GitHUB](https://github.com/git-guides)






# Конфликты и их разрешение

## _Работа с конфликтами в командной строке_


До этого момента мы или работали в одиночку, или с коллегой над разными участками кода. То есть не пересекались с другими программистами. На практике такое бывает редко, и случается, что приходится править те же участки кода, что и наши коллеги.

Посмотрим на практике

У нас есть блок учеников, он уже в мастере и выглядит так
***
    <ul>
        <li>Ivan Ivanov</li>
        <li>Petr Petrov</li>
    </ul>
***
Нам нужно доработать этот блок, мы создаем новую ветку students-redesign и изменяем этот блок. Мы хотим добавить классы к тегам  ***_ul_*** и ***_li_***. Получается так

***
    <ul class="students">
        <li class="students__fio">Ivan Ivanov</li>
        <li class="students__fio">Petr Petrov</li>
    </ul>
***

Закоммитим эти изменения и будем готовы залить в мастер. Но пока мы работали, нашему коллеге поручили добавить в этот же блок нового ученика. Эту задачу коллега уже сделал и залил в мастер. У него (и в мастере) код блока учеников теперь выглядит так


    <ul>
        <li>Ivan Ivanov</li>
        <li>Petr Petrov</li>
        <li>Stepan Sidorov</li>
    </ul>


То есть просто добавил еще один тег ***_li_***. Конечно, наших изменений он не видел.

Таким образом два человека правили код в одном и том же месте.

Мы переключаемся в мастер, пулимся, подтягиваем его коммит и пытаемся слить ее в мастер. И видим такое

***_$ git merge students-redesign_***
***

    Auto-merging index.html
    CONFLICT (content): Merge conflict in index.html
    Automatic merge failed; fix conflicts and then commit the result.
***

Здесь ***_git_*** говорит, что обнаружен конфликт. То есть в текущей ветки ***_(master)_*** и в той, которую мы пытаемся вмерджить ***_(students-redesign)_*** есть изменения в одних и тех же участках кода. Нужно посмотреть, в чем заключается конфликт. Открываем файл ***_index.html_*** и видим
***

    ++<<<<<<< HEAD
     +    <ul>
     +        <li>Ivan Ivanov</li>
     +        <li>Petr Petrov</li>
     +        <li>Stepan Sidorov</li>
    ++=======
    +     <ul class="students">
    +         <li class="students__fio">Ivan Ivanov</li>
    +         <li class="students__fio">Petr Petrov</li>
    ++>>>>>>> students-redesign



Угловые скобки ограничивают зону конфликта - те участки, где ***_git_*** видит изменения.

Блок между ***_<<<<<<< HEAD и =======_*** это код, который находится в текущей ветке, в мастере.
А код между ***_======= и >>>>>>> students-redesign_*** - то, что в ветке ***_students-redesign_***.

Чтобы не запутаться, ***_git_*** дает подсказки:
- ***_HEAD_*** - это текущая ветка,
- ***_students-redesign_*** - ветка, которую мы сливаем в текущую.

Наша задача - собрать эти 2 участка в одно целое. Добавить и изменения в ветку ***_students-redesign_***, и те, что уже приехали в мастер. Это называется разрешить конфликт или разрезолвить конфликт.

Приступим.

Мы помним, что наши изменения в ветке students-redesign это добавленные классы ***_students (ul) и students__fio (li)_***. Значит, их нужно оставить. А изменения в мастере - это новый ученик, новый тег ***_li_***, его тоже нужно оставить, но дописать к ***_li_*** класс ***_students__fio_***, чтобы теги были с одинаковыми классами
***
    <ul class="students">
        <li class="students__fio">Ivan Ivanov</li>
        <li class="students__fio">Petr Petrov</li>
        <li class="students__fio">Stepan Sidorov</li>
    </ul>
***

Мы оставили новые изменения и учли то, что приехало в мастер. Угловые скобки и значки ***_===_*** тоже нужно убрать - в итоге останется правильный ***_html_***.

Последнее, что останется сделать, это соощить ***_git_***, что конфликты разрешены. Для этого нужно закоммтить изменения так, мы привыкли, и не забыть запушить. То есть, коммит с фиксом конфликта - это самый обычный коммит.
***
    $ git add index.html 
    $ git commit -m 'Merge branch students-redesign'
    $ git push origin master
***



## Основы работы с удаленным репозиторием ##
***
- ***_git clone — создание копии (удаленного) репозитория_***
***
Для начала работы с центральным репозиторием, следует создать копию оригинального проекта со всей его историей локально.

Клонируем репозиторий, используя протокол http:
***
- ***_git clone http://user@somehost:port/~user/repository/project.git_***
***
Клонируем репозиторий с той же машины в директорию myrepo:
***
- ***_git clone /home/username/project myrepo_***
***
Клонируем репозиторий, используя безопасный протокол ssh:
***
- ***_git clone ssh://user@somehost:port/~user/repository_***
***

У git имеется и собственный протокол:
***
- ***_git clone git://user@somehost:port/~user/repository/project.git/_***
***

Импортируем svn репозиторий, используя протокол http:
***
- ***_git svn clone -s http://repo/location_***
***

***_-s_*** – понимать стандартные папки SVN (trunk, branches, tags)

***_git fetch и git pull_*** — забираем изменения из центрального репозитория
Для синхронизации текущей ветки с репозиторием используются команды ***_git fetch и git pull._***

- ***_git fetch_*** — забрать изменения удаленной ветки из репозитория по умолчания, основной ветки; той, которая была использована при клонировании репозитория. Изменения обновят удаленную ветку (remote tracking branch), после чего надо будет провести слияние с локальной ветку командой git merge.

- ***_git fetch /home/username/project_*** — забрать изменения из определенного репозитория.

Возможно также использовать синонимы для адресов, создаваемые командой ***_git remote:_***

- ***_git remote add username-project /home/username/project_***
- ***_git fetch username-project_*** — забрать изменения по адресу, определяемому синонимом.

Естественно, что после оценки изменений, например, командой ***_git diff_***, надо создать коммит слияния с основной:

- ***_git merge username-project/master_***
  
Команда ***_git pull_*** сразу забирает изменения и проводит слияние с активной веткой.

Забрать из репозитория, для которого были созданы удаленные ветки по умолчанию:

- ***_git pull_***
  
Забрать изменения и метки из определенного репозитория:

- ***_git pull username-project --tags_***
  
Как правило, используется сразу команда ***_git_*** pull.

- ***_git push_*** — вносим изменения в удаленный репозиторий

После проведения работы в экспериментальной ветке, слияния с основной, необходимо обновить удаленный репозиторий (удаленную ветку). Для этого используется команда ***_git push._***

Отправить свои изменения в удаленную ветку, созданную при клонировании по умолчанию:

- ***_git push_***

Отправить изменения из ветки master в ветку experimental удаленного репозитория:

- ***_git push ssh://yourserver.com/~you/proj.git master:experimental_***

В удаленном репозитории origin удалить ветку experimental:

- ***_git push origin :experimental_***

В удаленную ветку master репозитория origin (синоним репозитория по умолчанию) ветки локальной ветки master:

- ***_git push origin master:master_***

Отправить метки в удаленную ветку master репозитория origin:

- ***_git push origin master --tags_***

Изменить указатель для удаленной ветки master репозитория origin (master будет такой же как и develop)

- ***_git push origin origin/develop:master_***

Добавить ветку test в удаленный репозиторий origin, указывающую на коммит ветки develop:

- ***_git push origin origin/develop:refs/heads/test_***