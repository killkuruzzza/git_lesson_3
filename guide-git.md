# Иструкция по работе с GIT.

GIT -  это система управления версиями проекта.

GITHUB - своего рода соцсеть для хранения кода и совместной работы разработчиков над одним проектом или несколькими.

## 1.Регистрация GITHUB, установка GIT и основные настройки.

Чтобы зарегистрироваться на GITHUB, необходимо перейти по ссылке *<https://github.com>* и пройти стандартную регистрацию. 
там же можно скачать актуальную версию *Visual Studio Code*.

Далее требуется установить сервис:

+  Для линукс. 
Открыть терминал и установить приложение при помощи пакетного менеджера дистрибутива. Команда для Ubuntu: 
  `sudo apt-get install git`

+  Для windows.
Скчать вариант *git for windows*.

+ Для OS X. Воспользоваться homebrew. После его установки запустить в терминале:
  `brew install git`

## 2.Настройка GIT и GITHUB

После установки необходимо настроить GIT. Для настройки самых важных из множества опций нужно открыть терминал и запустить команды:
+ Команда для настройки имени пользователя: 
  `git config --global user name "My Name"`
+ Команда для настройки адреса электронной почты:
  `git config --global user.email myEmail@example.com`

GIT хранит весь пакет конфигураций в файле *.gitconfig*, который находится в локальном каталоге. Чтобы сделать эти настройки глобальными (применимыми ко всем проектам), необходимо добавить флаг *-global*. Иначе они будут распространяться только на текущий репозиторий.

Чтобы посмотреть все настройки системы, необходимо ввести команду: 
  `git config --list`

## 3.Помощь в GIT.

1. Информацию по другим настройкам, а так же командам и возникшим ошибкам можно найти, запросив общую документацию. Для этого небходимо ввести команду: 
  `git --help`

2. Чтобы получить информацию по определенной команде, необходимо ввести: 
  `git log --help`  
  (вместо log ввести необходимую команду)

3. Если команда введена с опечаткой, GIT укажет на ошибку и подскажет нужную команду.

4. После выполнения любой команды GIT отчитается о том, что было сделано.

5. GIT прогнозирует дальнейшие варианты развития событий и направит куда двигаться дальше.

## 4.Создание нового репозитория.

Для создания репозитория на GITHUB нужно войти в систему, в навигационной панели в правом верхнем углу кликнуть по "+" и выбрать пункт *"Новый репозиторий"* Или на главной странице зеленая кнопка *+Новый репозиторий*.
Далее заполнить поля:
* *Repository name*(имя репозитория)
* *Descrigtion* (описание)
* Оставить выбранным пункт *Public* и присвоить флажок  `"Initialize this repository with a README"`

Далее нажать кнопку *"Create repository"*. Готово! Репозиторий создан.

Чтобы создать новый репозиторий, необходимо открыть папку нашего проекта, создать файл, открыть терминал и ввести команду `git init`
В папке появится файлик *.git*, где будет храниться история репозитория и настройки.

Репозиторий, находящийся на GITHUB является главным. При работе с большими командными проектами, главный репозиторий создается руководителяли проектов. Все изменения подлежат предварительному утверждению.

## 5.Основные команды GIT.

1. *git status* - показывает информацию о текущем состоянии репозитория: актуальна ли информация, нет ли чего нового, что поменялось и т.д.

2. *git add* - индексирование изменений в рабочей директории для последующего коммита.

3. *git rm* - используется для удаления файлов из индекса и рабочей директории.

4. *git mv* - удобный способ переместить файл, а затем выполнить git add. 

5. *git commit* - сохраняет все изменения, добавленные в индекс командой git add.

6. *git log* - используется для просмотра истории коммитов, начиная с самого свежего до самых первых. По умолчанию она показывает лишь историю текущей ветки.

7.  *git branch* - используется чтобы перечислять ветки, создавать новые, удалять и переименовывать их.

8. *git checkout* - используется для переключения веток и выгрузки их содержимого в рабочую директорию.

9. *git merge* - используется для слияния одной или нескольких веток в текущую. 

10. *git stash* - используется для временного сохранения всех незакоммиченных изменений для очистки рабочей директории без необходимости коммитить незавершенную работу в новую ветку.

11. *git tag* - используется для задания постоянной метки на какой-либо момент в истории проекта. Обычно используется для релизов.

12. *git shortlog* - служит для подведения итогов команды *git log*. Она принимает практически те же параметры, что и *git log*, но вместо простого списка коммитов они будут сгруппированы по автору.

13. *git show* - отображает объект в простом виде. Обычно она используется для просмотра информации о метке или коммите.

14. *git pull* - получение изменений из главного репозитория.

15. *git push* - отправить изменения в главный репозиторий.

16. *git diff* - сравнить текущие изменения.

## 6.Базовые операции по работе с главным репозиторием.

### 1. Создание локальной копии главного репозитория.

Необходимо перейти в каталог, в котором будет располагаться копия каталога репозитория, и запустить в
нем терминал. 
* Для пользователей Linux/MacOS: запустить Терминал и с помощью
команды *cd* перейти в нужный каталог. 
* Для пользователей Windows: перейти в Проводнике в нужный каталог, щелкнуть правой кнопкой мыши в окне каталога и контекстном меню выбрать пункт *"Git Bash"*. 

После запуска в терминале набрать команду:   

`git clone https://github.com/(имя репозитория)/test`

В результате в текущем каталоге будет создан подкаталог *test*, содержащий копию главного репозитория. Для работы с репозиторием необходимо перейти в его каталог командой *cd test*. 

## 2. Добавление новых файлов в репозиторий.

 В каталоге репозитория *test* создать текстовый файл *first.txt*, содержащий строку текста *"Some text"*. Файл появился в каталоге репозитория, но *git* его еще не отслеживает. Добавить файл для отслеживания командой 
  
  `git add first.txt` 

Далее необходимо сохранить изменения и сделать коммит: 
 
  `git commit -­m "My first commit"` 

Ключ `-­m` позволяет задать описание коммита. Описание обязательно, иначе
коммит не будет выполнен. Далее создать каталог *dir*, а в нем два текстовых файла. *txt* и *b.txt*. Чтобы при добавлении в *git* не перечислять их по отдельности воспользуемся командой 
 
  `git add`

которая добавляет в *git* все новые файлы. И снова сохраним: 
   
  `git commit -­m "dir added"`

## 3.Отправка изменений в главный репозиторий.

Чтобы изменения, внесенные в локальную копию, появились в главном репозитории, их необходимо туда добавить.

Для этого используется команда:

  `git push`

В процессе выполнения команды потребуется ввести ваш и логин и пароль от аккаунта на GitHub. После успешного завершения команды обновим страничку с главным репозиторием. Теперь его содержимое совпадает с локальной копией репозитория.

## 4.Получение изменений из главного репозитория.

Для этого необходимо открыть еще один терминал в каталоге,
отличном от того, в котором лежит локальный репозиторий. И создать еще одну локальную копию главного репозитория (как ­ описано выше). Теперь есть два локальных репозитория: первый (старый) и второй (только что созданный). Представим, что второй репозиторий на самом деле находится на
другом компьютере и с ним работает второй участник. И он решает внести какие­то изменения в файл *first.txt* (например, добавим туда еще одну строчку текста), находящийся в его локальной копии, т.е. во втором репозитории. Сохраняем файл
и коммитим: 

  `git commit ­a ­m "more changes in first.txt"`
  
и отправляем изменения на сервер: 

   `git push`

Сейчас у нас синхронизированы главный и второй локальный репозитории, но первый локальный отстает. Ему нужно получить изменения из главного репозитория командой:

   `git pull`

Теперь у нас везде одинаковые версии. 

## 5.Разрешение конфликтов. 


 Чтобы возник конфликт, в нашем первом локальном репозитории внести изменения в файл *first.txt*, закоммитить и отправить их в главный репозиторий. А затем во втором локальном репозитории создать файл *second.txt* и тоже закоммитить. Если теперь из второго репозитория сделать *git push*, возникнет ошибка из-­за разницы изменений. Как исправить:
 + Сначала необходимо получить изменения из главного репозитория
 + затем объединить их с текущими изменениями в своей локальной копии
+ Затем то, что получилось, отправить на главный репозиторий. 

Для првых двух шагов импользуется команда: 

 `git pull`

Она достаточно умна, чтобы понять, что в этом случае надо обновить файл *first.txt* и добавить *second.txt*. После чего остается только отправить изменения командой 
 `git push`

Получается что при отправке изменений безопасно пользоваться двумя последовательными командами: 
 `git pull` 
 
  проверить на наличие новых изменений в репозитории и, если они есть, выкачать их и объединить с локальными изменениями

 `git push`  
 
  отправить изменения в репозиторий

Таким образом, git умеет разрешать конфликты самостоятельно. Но к сожалениюnне все. Если вместо создания *second.txt* во втором репозитории тоже изменили *first.txt*, то мы бы имели две измененные версии одного файла и здесь уже git самостоятельно разрешить конфликт не может: нужно вмешательство
человека. При грамотно спланированной работе команды, такие ситуации встречаются редко.

Посмотреть информацию о конфликтах можно в справке *git* по команде *merge* в разделе *"How to resolve conflicts"*. 
